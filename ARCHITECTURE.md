# Asdfghjkl Architecture

## Overview
Asdfghjkl is a macOS utility that replaces mouse navigation with a keyboard-driven overlay. A global event tap detects a double-tap of the Command key to toggle the overlay, keys refine a 4×10 grid that maps to the screen while warping the cursor to the refined centre, and pressing Space clicks without needing to move again. The package is split into a reusable core library and a macOS app target that hosts SwiftUI/AppKit windows for the overlay and zoom preview.

## Package layout
The Swift package exposes a platform-neutral `AsdfghjklCore` library alongside the `Asdfghjkl` executable target. Core contains the state machine, grid math, input handling, and mouse action abstractions, while the executable hosts the SwiftUI/AppKit presentation that subscribes to core state and renders overlay windows on every screen. Tests target the core library directly to keep UI concerns separate.

## Core layer
- **Grid navigation**: `GridLayout` maps keyboard characters onto a 4×10 grid and returns the subdivided rectangle for each key, enabling iterative refinement of the target region. `GridRect` provides geometric utilities including `center` for the midpoint, while `GridPartitioner` splits the columns across multiple displays so the first keypress selects the correct screen before drilling into that display.
- **Overlay state and control**: `OverlayController` owns the overlay lifecycle. It starts the overlay with the active screen bounds, refines the current rectangle on key presses, updates the zoom model, and deactivates after a click or cancel. The controller extracts clear helper methods: `selectScreenIfNeeded`, `refineGrid`, `applyRefinement`, and `updateZoom` make the key handling flow explicit. `OverlayState` holds the active flag, root bounds, refined rectangle, and derived target point so downstream consumers can react without duplicating business logic.
- **Input processing**: `InputManager` installs the CGEvent tap on macOS, routes modifier changes through `CommandTapRecognizer` to detect the double-Cmd gesture, and forwards key presses to the overlay controller. It also consumes Escape to cancel and Space to trigger the click, mirroring the keyboard-driven workflow even in non-AppKit builds (where it logs a stub message instead of creating the tap).
- **Pointer actions**: `MouseActionPerforming` abstracts cursor motion and clicking. The default `SystemMouseActionPerformer` can warp the cursor independently of clicks and post click events at the current target, while tests can inject stubs to assert coordinates without real side effects.
- **Zoom model**: `ZoomController` tracks the target rectangle, screen bounds, and zoom scale and, on macOS, captures a snapshot of the entire screen through a `ZoomSnapshotProviding` strategy (defaulting to `CGWindowListCreateImage`). It implements true pinch-to-zoom behavior: the entire screen snapshot is scaled by the zoom factor, and the target point stays fixed at its original screen position—if you zoom 200% at pixel (x,y), that pixel remains at (x,y) while everything else scales around it. The zoom offset calculation is broken into helper methods (`calculateZoomOffset`, `targetCenterInScreenCoordinates`, `clampOffset`, `targetEdgesInScreenCoordinates`) that make the transform math clearer. The target rectangle, screen rect, zoom scale, offset, and latest snapshot are published so UI components can update reactively.

## macOS app layer
- **App bootstrap**: `AppDelegate` wires the pieces together: it instantiates the grid layout, core controllers, and visual model; builds overlay windows per `NSScreen` with per-display grid slices; creates the zoom window; and starts the input manager. It rebuilds windows when screens change so overlays and partitions stay in sync. Window visibility is managed through `updateWindowVisibility`, which shows/hides overlay and zoom windows based on state.
- **Overlay windows**: `OverlayWindowController` hosts an `OverlayGridView` inside a borderless `NSWindow` at the `.screenSaver` level. The SwiftUI view draws the translucent grid and highlights the current target rectangle for each display while ignoring mouse events. Each window receives its own `GridSlice` and a reference to the shared `ZoomController` so labels and hit testing only cover the columns assigned to that screen. Grid content is wrapped with `ZoomTransformModifier` to apply zoom scale and offset directly from the controller.
- **Zoom window**: `ZoomWindowController` presents a full-screen borderless window with `ZoomPreviewView`. The window fills the entire screen containing the target point (via `screenContaining`), ensuring a stable frame during zoom transitions. `ZoomPreviewView` subscribes to the zoom controller's published properties and animates the content transform. The zoom behaves exactly like pinch-to-zoom on a phone: the target point stays fixed at its screen position while everything scales around it.
- **State bridging for SwiftUI**: `OverlayVisualModel` mirrors core overlay state as an `ObservableObject`, letting SwiftUI views animate visibility and highlights as the controller emits updates. Zoom state is not duplicated—views access `zoomScale` and `zoomOffset` directly from `ZoomController`. The app listens to `OverlayController.stateDidChange` and hops to the main actor with Swift concurrency tasks so UI updates stay in sync with the event tap callbacks while satisfying AppKit's main-thread isolation.

## Event flow
1. App launch initializes the controllers, windows, and screen observer, then starts the input manager.
2. Double-tapping Command toggles the overlay and shows the overlay windows; the zoom window remains hidden until the user refines.
3. Each key press refines the grid rectangle via the core layout; the first key maps to a display when multiple screens are present, after which refinements stay within that slice, move the cursor to the refined centre, and update the zoom snapshot and highlight.
4. Space posts a click at the refined target without warping again, after which the overlay hides; Escape cancels instead.
